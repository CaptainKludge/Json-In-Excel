{
    "jsonObject":  "=LAMBDA(range,   LET(     keys, INDEX(range,,1),     vals, INDEX(range,,2),      nonEmptyRows, safeFilter(SEQUENCE(ROWS(keys)), keys\u003c\u003e\"\"),      safeKeys, IFERROR(INDEX(keys, nonEmptyRows), \"\"),     safeVals, IFERROR(INDEX(vals, nonEmptyRows), \"\"),      pairStrings, MAP(safeKeys, safeVals,       LAMBDA(k,v, IF(k\u003c\u003e\"\", jsonQuote(k) \u0026 \":\" \u0026 v, \"\"))     ),      joined, TEXTJOIN(\",\", TRUE, safeFilter(pairStrings, pairStrings\u003c\u003e\"\")),      IF(joined=\"\", \"{}\", \"{\" \u0026 joined \u0026 \"}\")   ) )",
    "partFill":  "=LAMBDA(span,partarr,[extrahungry],   LET(     num, ROWS(partarr),       initialState, jsonObject(       HSTACK(         VSTACK(\"rem\",\"out\",\"row\"),         VSTACK(span,\"{ }\",\"0\")       )     ),      rowarray,       MAKEARRAY(         num, 1,         LAMBDA(rown,ind,           jsonObject(             HSTACK(               VSTACK(\"name\",\"len\",\"row\"),               VSTACK(INDEX(partarr,rown,1), INDEX(partarr,rown,2), rown)             )           )         )       ),      finalState,       REDUCE(         initialState,         rowarray,         LAMBDA(state,partJson,           LET(             rem, VALUE(IFERROR(jsonGet(state,\"rem\"),\"#BROKEN:rem\")),             outJson, IFERROR(jsonGet(state,\"out\"),\"#MISSING:out\"),             rownum, VALUE(IFERROR(jsonGet(state,\"row\"),\"#BROKEN:row\")),             pname, IFERROR(jsonGet(partJson,\"name\"),\"#BROKEN:name\"),             plen, VALUE(IFERROR(jsonGet(partJson,\"len\"),\"#BROKEN:len\")),             lastpart, IFERROR(jsonGet(state,\"lastpart\"),\"#BROKEN:lastpart\"),             lenlpart, IFERROR(jsonGet(state,\"lenlpart\"),\"#BROKEN:lenlpart\"),              pcount, INT(rem/plen),             newRem, rem - pcount*plen,              fcount, IF(AND(NOT(ISNA(additionalconfig)), newRem\u003c0, pcount\u003e0), pcount-1, pcount),             finalRem, rem - fcount*plen,              newOut,               IF(NUMBERVALUE(fcount)\u003e0,                  IFERROR(jsonSet(outJson,pname,fcount),\"#SETERR:newOut:\"\u0026pname\u0026\":\"\u0026fcount),                  outJson               ),              IFERROR(               jsonSet(                 IFERROR(jsonSet(state,\"rem\",finalRem),\"#SETERR:rem\"),                 \"out\",newOut               ),               \"#SETERR:out\"             )           )         )       ),     additionalconfig, IF(ISOMITTED(extrahungry),jsonGet(finalState,\"out\"),jsonJoin(jsonGet(finalState,\"out\"),FILTER(INDEX(extrahungry,,1),between(jsonGet(finalState,\"rem\"),INDEX(extrahungry,,2))),2)),     additionalconfig   ) )",
    "jsonJoin":  "=LAMBDA(JSON1,JSONNEW,MODE,LET(solver,LAMBDA(JSON2,LET(WALK,LAMBDA(JSONE,JSTWO,SUBMODE,DEPTH,SELF,IF(DEPTH\u003e10,\"#STOP:recursiontoodeep\",LET(JsonSet1,jsonGetKeysAtLevel(JSONE),JsonSet2,jsonGetKeysAtLevel(JSTWO),ReduceSET,MAP(INDEX(JsonSet2,,1),INDEX(JsonSet2,,2),LAMBDA(ARRAYONE,ARRAYTWO,jsonObject(HSTACK(ARRAYONE,ARRAYTWO)))),RESULT,REDUCE(JsonSet1,ReduceSET,LAMBDA(returnset,testsetobj,LET(objkeyset,jsonGetKeysAtLevel(testsetobj),key,INDEX(objkeyset,1,1),value,INDEX(objkeyset,1,2),keys,INDEX(returnset,,1),values,INDEX(returnset,,2),keypresent,SUM(--(keys=key))\u003e0,oldvalue,IF(keypresent,INDEX(FILTER(returnset,INDEX(returnset,,1)=key),1,2),NA()),test1,IF(ISNA(oldvalue),\"NA\",LEFT(TRIM(oldvalue),1)),test2,IF(ISNA(value),\"NA\",LEFT(TRIM(value),1)),isObjectPair,IFERROR(AND(test1=\"{\",test2=\"{\"),FALSE),isListPair,IFERROR(AND(test1=\"[\",test2=\"[\"),FALSE),normmode,SUBMODE=0,repMode,SUBMODE=1,addMode,SUBMODE=2,SWITCH(TRUE,AND(keypresent,NOT(repMode),isObjectPair),arrayRepAdd(returnset,key,SELF(oldvalue,value,SUBMODE,DEPTH+1,SELF)),AND(keypresent,NOT(repMode),isListPair),arrayRepAdd(returnset,key,listToJson(VSTACK(listFromJson(oldvalue),listFromJson(value)))),AND(addMode,XOR(test1=\"[\",test2=\"[\")),IF(test1=\"[\",arrayRepAdd(returnset,key,listToJson(VSTACK(listFromJson(oldvalue),value))),arrayRepAdd(returnset,key,listToJson(VSTACK(oldvalue,listFromJson(value))))),AND(keypresent,addMode),arrayRepAdd(returnset,key,IF(AND(NOT(ISERROR(VALUE(oldvalue))),NOT(ISERROR(VALUE(value)))),VALUE(oldvalue)+VALUE(value),oldvalue\u0026value)),arrayRepAdd(returnset,key,value))))),jsonObject(RESULT)))),WALK(JSON1,JSON2,MODE,0,WALK))),MAP(JSONNEW,solver)))",
    "arrayRepAdd":  "=LAMBDA(arr,key,val,   LET(     safeArr, IF(ROWS(arr)=0, HSTACK(\"\", \"\"), arr),     kcol, INDEX(safeArr,,1),     vcol, INDEX(safeArr,,2),     newarr, safeFilter(safeArr, kcol\u003c\u003ekey),     cleanArr, IF(ROWS(newarr)=0, HSTACK(\"\", \"\"), newarr),     VSTACK(cleanArr, HSTACK(key, jsonQuote(val)))   ) )",
    "jsonQuote":  "=LAMBDA(val,   LET(     s, TRIM(val),      isObjOrArr, REGEXTEST(s, \"^\\s*(\\{.*\\}|\\[.*\\])\\s*$\"),     isBoolNull, REGEXTEST(s, \"^(?i:true|false|null)$\"),     isNum, REGEXTEST(s, \"^-?\\d+(\\.\\d+)?([eE][+-]?\\d+)?$\"),      isProperQuoted, REGEXTEST(s, \"^\"\"[^\"\"]*\"\"$\"),      stripOuter, REGEXREPLACE(s, \"^\"\"+|\"\"+$\", \"\"),      core, REGEXREPLACE(stripOuter, \"(\"\"\"\")\", \"\u0027\"),      result,       IF(isObjOrArr, s,       IF(isNum, s,       IF(isBoolNull, LOWER(s),       IF(isProperQuoted, s,          \"\"\"\" \u0026 core \u0026 \"\"\"\"       )))),      result   ) )",
    "listToJson":  "=LAMBDA(arr,   LET(     quoted, MAP(arr, LAMBDA(x, jsonQuote(x))),     joined, TEXTJOIN(\",\",TRUE,quoted),     \"[\" \u0026 joined \u0026 \"]\"   ) )",
    "jsonGetKeysAtLevel":  "=LAMBDA(json,   LET(     content, IF(LEFT(json,1)=\"{\", MID(json,2,LEN(json)-2), json),     chars, MID(content, SEQUENCE(LEN(content)), 1),      initialState, VSTACK(\"\", 0, 0, FALSE, \"-0-0-FALSE\",\"\"),      processed,       REDUCE(         initialState,         chars,         LAMBDA(state,ch,           LET(             token, INDEX(state,1),             curl, INDEX(state,2),             square, INDEX(state,3),             quotes, INDEX(state,4),             info, INDEX(state,5),             tail, IF(ROWS(state)\u003e5, DROP(state,5), \"\"),              isQuote, ch=CHAR(34),             newQuotes, IF(isQuote, NOT(quotes), quotes),              newCurl, IF(quotes, curl, IF(ch=\"{\", curl+1, IF(ch=\"}\", curl-1, curl))),             newSquare, IF(quotes, square, IF(ch=\"[\", square+1, IF(ch=\"]\", square-1, square))),             level, newCurl+newSquare,              isSplit, AND(ch=\",\", level=0, NOT(newQuotes)),             newToken, IF(isSplit, \"\", token\u0026ch),             newTail, IF(isSplit, VSTACK(tail, token), tail),              newInfo, TEXTJOIN(\"-\",TRUE,info,\";\",isSplit,newToken,newCurl,newSquare,newQuotes),              VSTACK(newToken,newCurl,newSquare,newQuotes,newInfo,newTail)           )         )       ),      rawPairs, IF(ROWS(processed)\u003e5, DROP(processed,5), \"\"),      lastToken, INDEX(processed,1),     combined, IF(lastToken\u003c\u003e\"\", VSTACK(rawPairs,lastToken), rawPairs),      allPairs, IFERROR(FILTER(combined, combined\u003c\u003e\"\"), \"\"),      keypairs,       REDUCE(         {\"\",\"\"},         allPairs,         LAMBDA(acc,pair,           LET(             hasColon, ISNUMBER(SEARCH(\":\",pair)),             sep, IF(hasColon, TEXTAFTER(pair,\":\"), \"\"),             key, IF(hasColon, TEXTBEFORE(pair,\":\"), pair),             cleanKey, TRIM(SUBSTITUTE(key, \"\"\"\",\"\")),             cleanVal, TRIM(sep),             VSTACK(acc,HSTACK(cleanKey,cleanVal))           )         )       ),      IF(ROWS(keypairs)\u003e1, DROP(keypairs,1), keypairs)   ) )",
    "safeDrop":  "=LAMBDA(arr,rows,   LET(     dropped, IFERROR(DROP(arr, rows),MAKEARRAY(1, COLUMNS(arr), LAMBDA(r,c,\"\"))),     out, dropped,     out   ) )",
    "between":  "=LAMBDA(numberinpreclean,rangein, LET(     parseset, LAMBDA(singleset,           LET(             raw, TRIM(singleset),             numberin,VALUE(TRIM(numberinpreclean)),             safe, SUBSTITUTE(REGEXREPLACE(raw, \"([(\\[].*?),(.*?[\\])])\", \"$1|$2\"),\" \",\"\"),             intervals, TEXTSPLIT(safe, \",\"),             parseInterval, LAMBDA(tok,                    LET(                      t, TRIM(SUBSTITUTE(tok,\"|\",\",\")),                       hasBraces, OR(LEFT(t,1)=\"(\", LEFT(t,1)=\"[\"),                        dashParts, IF(hasBraces, \"\", TEXTSPLIT(t,\"-\")),                       leftB, IF(hasBraces, LEFT(t,1), \"[\"),                      rightB, IF(hasBraces, RIGHT(t,1), \"]\"),                      body, IF(hasBraces, MID(t,2,LEN(t)-2), t),                       nums, IF(                        hasBraces,                        REGEXEXTRACT(body,\"([-0-9]+(?:\\.[-0-9]+)?)?,([-0-9]+(?:\\.[-0-9]+)?)?\",2),                        \"\"                      ),                       minRaw, IF(hasBraces, IFERROR(INDEX(nums,1),-1E+99), IF(COUNTA(dashParts)\u003e=1,TRIM(INDEX(dashParts,1)),\"\")),                      maxRaw, IF(hasBraces, IFERROR(INDEX(nums,2),1E+99), IF(COUNTA(dashParts)=2,TRIM(INDEX(dashParts,2)),\"\")),                       min, IF(OR(minRaw=\"\",minRaw=\"-∞\"), -1E+99, VALUE(minRaw)),                      max, IF(OR(maxRaw=\"\",maxRaw=\"∞\",maxRaw=\"+∞\"), 1E+99, VALUE(maxRaw)),                       lowerOK, IF(leftB=\"(\", numberin\u003emin, numberin\u003e=min),                      upperOK, IF(rightB=\")\", numberin\u003cmax, numberin\u003c=max),                       AND(lowerOK,upperOK)                    )                   ),                   result, OR(MAP(intervals, parseInterval)),                   result             )         ),     MAP(rangein,parseset)) )",
    "jsonRemove":  "=LAMBDA(oJson,oPath,   LET(     walk,       LAMBDA(J,P,self,depth,         IF(depth\u003e20,\"STOP@\"\u0026P,           LET(             set, jsonGetKeysAtLevel(J),             parts, TEXTSPLIT(P,,\"/\",TRUE),             n, ROWS(parts),             hasTail, n\u003e1,              key, INDEX(parts,1),             tail, IF(hasTail, TEXTJOIN(\"/\",,DROP(parts,1)), \"\"),              keys, IFERROR(INDEX(set,,1), MAKEARRAY(1,1,LAMBDA(r,c,\"\"))),             keypresent, SUM(--(keys=key))\u003e0,              curRaw, IF(keypresent,jsonGet(J,key),NA()),             isObj, AND(NOT(ISNA(curRaw)),LEFT(TRIM(curRaw),1)=\"{\"),              result,               SWITCH(TRUE,                 AND(hasTail,keypresent,isObj),                   jsonObject(arrayRepAdd(set,key,self(curRaw,tail,self,depth+1))),                  NOT(hasTail),                   jsonObject(safeFilter(set,keys\u003c\u003ekey)),                  J               ),result)         )       ),     walk(oJson,oPath,walk,0)   ) )",
    "jsonGet":  "=LAMBDA(json,path,   LET(     keys, TEXTSPLIT(path,\"/\"),     REDUCE(       json,       keys,       LAMBDA(j,k,         LET(           pairs, jsonGetKeysAtLevel(j),           vals, IFERROR(FILTER(pairs, INDEX(pairs,,1)=k), \"\"),           IF(OR(vals=\"\", ROWS(vals)=0), NA(), TEXTJOIN(\",\",TRUE,INDEX(vals,,2)))         )       )     )   ) )",
    "GREEDYPARTFILL":  "=LAMBDA(targetLength,partArray,[pad],[extraHungry],   LET(     padVal, IF(ISOMITTED(pad), 0, pad),     isExtraHungry, IF(ISOMITTED(extraHungry), FALSE, extraHungry),      totalLength, targetLength + padVal,     partNames, INDEX(partArray,,1),     partLengths, INDEX(partArray,,2),     numParts, ROWS(partArray),      fillLoop, LAMBDA(index,state,       LET(         remaining, INDEX(state,1),         used, INDEX(state,2),         name, INDEX(partNames, index),         length, INDEX(partLengths, index),         count, IF(length \u003e 0, INT(remaining / length), 0),         newRemain, IF(length \u003e 0, remaining - count * length, remaining),         newUsed, IF(count \u003e 0,           HSTACK(used, HSTACK(name, count)),           used         ),         VSTACK(newRemain, newUsed)       )     ),      reduceResult, REDUCE(       VSTACK(totalLength, \"\"),       SEQUENCE(numParts),       fillLoop     ),      leftover, INDEX(reduceResult, 1),     usedRaw, INDEX(reduceResult, 2),      lastName, INDEX(partNames, numParts),     lastLength, INDEX(partLengths, numParts),      adjustedUsed, IF(       isExtraHungry * (leftover \u003e 0) * (lastLength \u003e leftover),       LET(         matchIndex, XMATCH(lastName, INDEX(usedRaw,,1), 0),         oldCount, IF(ISNUMBER(matchIndex), INDEX(usedRaw,,2, matchIndex), 0),         newCount, oldCount + 1,         namesFiltered, IFERROR(FILTER(INDEX(usedRaw,,1), INDEX(usedRaw,,1)\u003c\u003elastName), \"\"),         countsFiltered, IFERROR(FILTER(INDEX(usedRaw,,2), INDEX(usedRaw,,1)\u003c\u003elastName), \"\"),         finalNames, IF(namesFiltered=\"\", lastName, VSTACK(namesFiltered, lastName)),         finalCounts, IF(countsFiltered=\"\", newCount, VSTACK(countsFiltered, newCount)),         HSTACK(finalNames, finalCounts)       ),       usedRaw     ),      resultText, TEXTJOIN(\",\", TRUE,       MAP(         INDEX(adjustedUsed,,1), INDEX(adjustedUsed,,2),         LAMBDA(n,c, TEXTJOIN(\",\", TRUE, SEQUENCE(c,,n)))       )     ),      resultText   ) )",
    "nestedJsonBuild":  "= LAMBDA(p,v,   LET(     parts, TEXTSPLIT(p,,\"/\",TRUE),     IF(OR(p=\"\", ROWS(parts)=0),       jsonQuote(v),       LET(         rev, INDEX(parts, SEQUENCE(ROWS(parts),1,ROWS(parts),-1)),         REDUCE(           jsonQuote(v),           rev,           LAMBDA(acc,layer, jsonObject(HSTACK(layer, acc)))         )       )     )   ) )",
    "jsonSet":  "=LAMBDA(oJson,oPath,oValue,   LET(     MAX_DEPTH, 10,     walk,       LAMBDA(J,P,V,depth,self,         IF(depth\u003eMAX_DEPTH, \"#STOP@\"\u0026P,           LET(             set, jsonGetKeysAtLevel(J),             parts, TEXTSPLIT(P,,\"/\",TRUE),             n, ROWS(parts),             hasTail, n\u003e1,             key, INDEX(parts,1),             tail, IF(hasTail, TEXTJOIN(\"/\",,DROP(parts,1)), \"\"),              keys, IFERROR(INDEX(set,,1), MAKEARRAY(1,1,LAMBDA(r,c,\"\"))),             keypresent, SUM(--(keys=key))\u003e0,              curRaw, IF(keypresent, jsonGet(J,key), \"\"),             isObj, AND(keypresent, LEFT(TRIM(curRaw),1)=\"{\"),             newValQ, jsonQuote(V),              result,               SWITCH(TRUE,                 AND(hasTail, keypresent, isObj),                   jsonObject(                     arrayRepAdd(set,key,self(curRaw,tail,V,depth+1,self))                   ),                 AND(hasTail, keypresent, NOT(isObj)),                   jsonObject(                     arrayRepAdd(set,key,nestedJsonBuild(tail,V))                   ),                 hasTail,                   jsonObject(                     arrayRepAdd(set,key,nestedJsonBuild(tail,V))                   ),                 AND(NOT(hasTail), keypresent),                   jsonObject(arrayRepAdd(set,key,newValQ)),                 AND(NOT(hasTail), NOT(keypresent)),                   jsonObject(VSTACK(set,HSTACK(key,newValQ))),                 ISNA(set),                   \"#SETERR:notObject@\"\u0026P,                 TRUE,                   \"#SETERR:unhandled@\"\u0026P               ),             result           )         )       ),     walk(oJson,oPath,oValue,0,walk)   ) )",
    "safeFilter":  "= LAMBDA(arr,include,   LET(     cols, COLUMNS(arr),     safe, IFERROR(FILTER(arr, include), MAKEARRAY(1, cols, LAMBDA(r,c,\"\"))),     safe   ) )",
    "makearr":  "=LAMBDA(arr,MAKEARRAY(ROWS(arr),COLUMNS(arr),LAMBDA(a,b,INDEX(arr,a,b))))",
    "listFromJson":  "=LAMBDA(json,   LET(     inner, MID(TRIM(json),2,LEN(TRIM(json))-2),     parts, IF(inner=\"\", MAKEARRAY(0,1,LAMBDA(r,c,\"\")), TEXTSPLIT(inner, \",\",,TRUE)),     TRIM(SUBSTITUTE(parts, \"\"\"\", \"\"))   ) )"
}
